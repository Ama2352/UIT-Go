# =============================================================================
# CD Workflow - Deploy to Azure VM
# =============================================================================
# Runs: After Terraform Apply creates/updates the VM, or manually
# What it does:
#   1. SSH into Azure VM
#   2. Clone/pull latest code
#   3. Start services with docker compose
#   4. Run health checks
# =============================================================================

name: CD - Deploy to Azure

on:
  # Automatically run after Terraform workflow completes
  workflow_run:
    workflows: ["Infrastructure - Terraform"]
    types:
      - completed
    branches: 
      - main
      - feature/terraform-azure-cicd
      - fix/azure-deploy
  
  # Allow manual trigger
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Azure VM
    runs-on: ubuntu-latest
    
    # Run if: Terraform was successful (apply) or manual trigger
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Wait for VM to be ready
        run: |
          echo "Waiting 60 seconds for VM to finish cloud-init..."
          sleep 60
      
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.AZURE_VM_HOST }}
          username: ${{ secrets.AZURE_VM_USERNAME }}
          key: ${{ secrets.AZURE_VM_SSH_KEY }}
          command_timeout: 15m
          script: |
            echo "=========================================="
            echo "Starting deployment..."
            echo "=========================================="
            
            # Ensure Docker is in PATH and running
            export PATH=$PATH:/usr/bin:/usr/local/bin
            
            # Wait for cloud-init to complete (in case VM just started)
            echo "Waiting for cloud-init to complete..."
            sudo cloud-init status --wait || true
            
            # Ensure Docker is running
            echo "Ensuring Docker is running..."
            sudo systemctl start docker || true
            sudo systemctl enable docker || true
            
            # Verify Docker is available
            if ! command -v docker &> /dev/null; then
              echo "Docker not found. Installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              sudo usermod -aG docker $USER
              sudo systemctl start docker
              rm get-docker.sh
            fi
            
            # Check if app directory exists, if not clone it
            if [ ! -d "/opt/uit-go" ]; then
              echo "Cloning repository for the first time..."
              sudo mkdir -p /opt/uit-go
              sudo chown $USER:$USER /opt/uit-go
              git clone https://github.com/${{ github.repository }}.git /opt/uit-go
            fi
            
            # Navigate to app directory
            cd /opt/uit-go
            
            # Pull latest code
            echo "Pulling latest code..."
            git fetch origin
            git checkout ${{ github.ref_name }} || git checkout main
            git pull
            
            # Create .env file if it doesn't exist
            if [ ! -f ".env" ]; then
              echo "Creating .env file..."
              cat > .env << 'EOF'
            # Database - User Service
            USERDB_USERNAME=postgres
            USERDB_PASSWORD=postgres
            USERDB_DATABASE=userdb
            DATABASE_URL=postgresql://postgres:postgres@user-postgres:5432/userdb
            
            # Database - Trip Service
            TRIPDB_USERNAME=postgres
            TRIPDB_PASSWORD=postgres
            TRIPDB_DATABASE=tripdb
            TRIPDB_URL=jdbc:postgresql://trip-postgres:5432/tripdb
            
            # JWT
            JWT_SECRET=your-super-secret-jwt-key-change-in-production
            JWT_EXPIRES_IN=7d
            
            # RabbitMQ
            RABBITMQ_USER=guest
            RABBITMQ_PASSWORD=guest
            EOF
            fi
            
            # Build and start services (using sudo to ensure docker access)
            echo "Starting Docker Compose services..."
            sudo docker compose down --remove-orphans || true
            sudo docker compose up -d --build
            
            # Wait for services to start
            echo "Waiting for services to start..."
            sleep 60
            
            # Show current status
            echo "=========================================="
            echo "Current service status:"
            echo "=========================================="
            sudo docker compose ps
            
            # Show logs if any container is not running
            echo ""
            echo "Checking for any failed containers..."
            sudo docker compose ps --format json | grep -v "running" && sudo docker compose logs --tail=50 || echo "All containers are running!"
            
            echo ""
            echo "Deployment complete!"
      
      - name: Health Check & API Tests
        run: |
          echo "=========================================="
          echo "Running Health Checks & API Tests..."
          echo "=========================================="
          
          VM_HOST="${{ secrets.AZURE_VM_HOST }}"
          BASE_URL="http://${VM_HOST}:8000"
          
          # Function to test endpoint
          test_endpoint() {
            local name="$1"
            local url="$2"
            local expected_code="${3:-200}"
            
            echo ""
            echo "Testing: $name"
            echo "URL: $url"
            
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$url" 2>/dev/null || echo "000")
            
            if [ "$HTTP_STATUS" = "000" ]; then
              echo "‚ùå FAILED: Could not connect to $name"
              return 1
            elif [ "$HTTP_STATUS" = "$expected_code" ]; then
              echo "‚úÖ PASSED: $name responded with status $HTTP_STATUS"
              return 0
            else
              echo "‚ö†Ô∏è WARNING: $name responded with status $HTTP_STATUS (expected $expected_code)"
              return 0
            fi
          }
          
          # Wait for services to be fully ready
          echo "Waiting 30 seconds for services to be fully ready..."
          sleep 30
          
          # Track test results
          TESTS_PASSED=0
          TESTS_FAILED=0
          
          # Test Kong Gateway (root returns 404 which is expected)
          if test_endpoint "Kong Gateway" "${BASE_URL}/" "404"; then
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi
          
          # Test User Service health endpoint
          if test_endpoint "User Service Health" "${BASE_URL}/api/users/health" "200"; then
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi
          
          # Test Trip Service health endpoint
          if test_endpoint "Trip Service Health" "${BASE_URL}/api/trips/health" "200"; then
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi
          
          # Test Driver Service health endpoint
          if test_endpoint "Driver Service Health" "${BASE_URL}/api/drivers/health" "200"; then
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi
          
          # Test User Registration endpoint (should return 400 or 201 depending on payload)
          echo ""
          echo "Testing: User Registration Endpoint (POST)"
          REG_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "${BASE_URL}/api/users/auth/register" \
            -H "Content-Type: application/json" \
            -d '{"email":"test@example.com","password":"Test1234!","name":"Test User"}' \
            --max-time 30 2>/dev/null || echo -e "\n000")
          
          REG_STATUS=$(echo "$REG_RESPONSE" | tail -n1)
          REG_BODY=$(echo "$REG_RESPONSE" | sed '$d')
          
          if [ "$REG_STATUS" = "000" ]; then
            echo "‚ùå FAILED: Could not connect to User Registration endpoint"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          elif [ "$REG_STATUS" = "201" ] || [ "$REG_STATUS" = "400" ] || [ "$REG_STATUS" = "409" ]; then
            echo "‚úÖ PASSED: User Registration endpoint responded with status $REG_STATUS"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "‚ö†Ô∏è WARNING: User Registration responded with status $REG_STATUS"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          fi
          
          # Summary
          echo ""
          echo "=========================================="
          echo "Test Summary"
          echo "=========================================="
          echo "‚úÖ Passed: $TESTS_PASSED"
          echo "‚ùå Failed: $TESTS_FAILED"
          echo ""
          
          if [ $TESTS_FAILED -gt 0 ]; then
            echo "‚ö†Ô∏è Some tests failed. Services might still be starting up."
            echo "Please check the VM logs for more details."
          else
            echo "üéâ All tests passed!"
          fi
          
          echo ""
          echo "=========================================="
          echo "Deployment Complete!"
          echo "=========================================="
          echo "API Gateway: ${BASE_URL}"
          echo ""
          echo "Available Endpoints:"
          echo "  - User Service:   ${BASE_URL}/api/users/*"
          echo "  - Trip Service:   ${BASE_URL}/api/trips/*"
          echo "  - Driver Service: ${BASE_URL}/api/drivers/*"
          echo "==========================================""
